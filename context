// ============================================================================
// AI DUNGEON SCRIPTING REFERENCE - BEST PRACTICES EDITION (v2.3)
//
// This template demonstrates the AI Dungeon scripting API with production-
// ready best practices based on extensive testing and validation.
//
// Official Documentation:
// https://help.aidungeon.com/scripting
// https://github.com/magicoflolis/aidungeon.js/blob/main/Scripting%20Guidebook.md
//
// Key Best Practices:
// 1. Always use defensive null checks for state and memory access
// 2. Avoid ES6 template literals - use string concatenation instead
// 3. Validate all configuration values with min/max clamping
// 4. Use state object for persistent data between turns
// 5. Check typeof before accessing potentially undefined objects
// 6. Use categorized debug logging for maintainability (v2.3+)
// 7. Implement performance monitoring for critical sections (v2.3+)
// ============================================================================

// Every script needs a modifier function
const modifier = (text) => {
  // ========================================
  // LOGGING AND DEBUG OUTPUT
  // ========================================

  // You can use log or console.log for debug output
  // log('Hello World')
  // console.log('Hello World')

  // BEST PRACTICE: Avoid template literals for AI Dungeon compatibility
  // log('Value: ' + state.value)  // ✓ Compatible
  // log(`Value: ${state.value}`)  // ✗ May not work

  // ========================================
  // READING CURRENT TEXT
  // ========================================

  // You can read the current text
  // This is the text that would otherwise be sent to the AI model
  // log(text)

  // ========================================
  // READING HISTORY
  // ========================================

  // You can read the current history
  // log(history)

  // ========================================
  // STATE MANAGEMENT (PERSISTENT DATA)
  // ========================================

  // Use state to store information between turns
  // State persists across all turns in the adventure
  // log(state)
  // state.example = 'Hello World!'

  // BEST PRACTICE: Initialize state values with null checks
  // if (typeof state.myValue === 'undefined' || state.myValue === null) {
  //   state.myValue = 100
  // }

  // ========================================
  // MEMORY MANAGEMENT
  // ========================================

  // BEST PRACTICE: Always check if state.memory exists before accessing
  // Unsafe (may crash):
  // state.memory.context = 'Hello Memory!'

  // Safe approach:
  // if (state.memory) {
  //   state.memory.context = 'Hello Memory!'
  // }

  // You can update the authors note (CRITICAL: check for null!)
  // if (state.memory) {
  //   state.memory.authorsNote = 'Hello Authors Note!'
  // }

  // ========================================
  // PLAYER MESSAGES
  // ========================================

  // You can display messages to the player
  // state.message = 'Hello Player!'

  // ========================================
  // STORY CARDS
  // ========================================

  // You can read the current story cards
  // log(storyCards)

  // You can add a story card
  // addStoryCard('exampleKey', 'exampleEntry', 'exampleType', 'exampleName', 'exampleNotes', { returnCard: false })

  // You can remove a story card
  // removeStoryCard(0)

  // You can update a story card
  // updateStoryCard(0, 'exampleKey', 'exampleEntry', 'exampleType', 'exampleName', 'exampleNotes')

  // BEST PRACTICE: Reading story cards safely
  // function getStoryCardEntry(cardKey) {
  //   if (typeof storyCards === 'undefined' || !storyCards || storyCards.length === 0) {
  //     return ""
  //   }
  //   for (let i = 0; i < storyCards.length; i++) {
  //     if (storyCards[i] && storyCards[i].keys === cardKey) {
  //       return storyCards[i].entry || ""
  //     }
  //   }
  //   return ""
  // }

  // ARKHAM ENGINE FEATURE: PlayersAuthorsNote story card
  // The Arkham Fate Engine automatically creates a story card called
  // 'PlayersAuthorsNote' on turn 1. Edit this card to add custom
  // directives that will be appended to the author's note after the
  // story arc information.

  // ARKHAM ENGINE FEATURE: ArkhamStatus story card
  // The Arkham Fate Engine creates a story card called 'ArkhamStatus'
  // on turn 1 that displays:
  // - Current HP / Maximum HP
  // - Current SP / Maximum SP
  // - Grace Period Turns (editable)
  //
  // You can edit the "Grace Period Turns" value to change how long
  // the grace period lasts (0-100 turns). Changes take effect on
  // the next turn. The card automatically updates with current HP/SP
  // values every turn.

  // ========================================
  // INFO OBJECT (TURN METADATA)
  // ========================================

  // BEST PRACTICE: Check if info exists before accessing
  // The info object only exists on certain turns

  // Safe way to check if this is a player turn:
  // const isPlayerTurn = (typeof info !== 'undefined' && info !== null && info.actionType === 'input')

  // Available info properties:
  // info.actionCount - number of actions in the adventure so far
  // info.characterNames - array of character names for multiplayer
  // info.memoryLength - (deprecated) length of memory section
  // info.contextTokens - number of context tokens available
  // info.maxChars - maximum length that text can be

  // Safe logging:
  // if (typeof info !== 'undefined' && info !== null) {
  //   log('Action count: ' + info.actionCount)
  // }

  // ========================================
  // MODIFYING OUTPUT
  // ========================================

  // You can change the player's context text
  // const newText = 'I see you...'
  // return { text: newText }

  // You can stop the action from proceeding
  // return { stop: true }

  // ========================================
  // RETURN VALUE (ALWAYS REQUIRED)
  // ========================================

  // You can let the action proceed as normal
  // IMPORTANT: Always return an object with a text property
  return { text: text }
}

// ============================================================================
// ARKHAM FATE ENGINE v2.3 DEBUG SYSTEM
// ============================================================================

// The Arkham Fate Engine v2.3 introduces a comprehensive debug system with
// categorized logging, performance monitoring, and player-accessible commands.

// DEBUG LEVELS (0-5):
// 0 = NONE  - No logging
// 1 = ERROR - Critical errors only
// 2 = WARN  - Warnings and errors
// 3 = INFO  - General information (default)
// 4 = DEBUG - Detailed debugging
// 5 = TRACE - Very verbose tracing

// DEBUG CATEGORIES:
// INIT  - System initialization and configuration
// TEMP  - Temperature/heat mechanics
// HP    - Health point system
// SP    - Sanity point system
// GRACE - Grace period mechanics
// WORDS - Word detection (verbose)
// STORY - Story cards and author's note
// PERF  - Performance monitoring

// PLAYER COMMANDS:
// /debug <0-5>        - Set debug level
// /debug <category>   - Toggle category on/off
// /debug status       - Show debug configuration
// /perf on/off        - Enable/disable performance monitoring
// /perf status        - Show performance metrics

// EXAMPLE DEBUG LOGGING:
// Instead of: log("System initialized")
// Use: logInfo(DEBUG.INIT, "System initialized", {turnCount: 1})

// EXAMPLE PERFORMANCE MONITORING:
// const perfTimer = perfStart('my_function')
// // ... do expensive work ...
// perfEnd(perfTimer)  // Logs if >1000ms

// DEBUG SYSTEM FUNCTIONS AVAILABLE IN INPUT/OUTPUT SCRIPTS:
// - debugLog(level, category, message, data)
// - logError(category, message, data)
// - logWarn(category, message, data)
// - logInfo(category, message, data)
// - logDebug(category, message, data)
// - logTrace(category, message, data)
// - perfStart(section)
// - perfEnd(perfTimer)
// - handleError(severity, category, message, error, context)
// - enterSafeMode()
// - exitSafeMode()

// ============================================================================
// ADDITIONAL BEST PRACTICES FROM ARKHAM FATE ENGINE v2.2+
// ============================================================================

// 1. VALUE VALIDATION AND CLAMPING
// Always validate and clamp numeric configuration values:
//
// function clamp(value, min, max) {
//   const num = Number(value)
//   if (isNaN(num)) return min
//   return Math.max(min, Math.min(num, max))
// }
//
// state.myValue = clamp(state.myValue, 0, 100)

// 2. BOOLEAN COERCION
// Handle multiple boolean input formats:
//
// function bool(value) {
//   return value === true || value === 'true' || value === 1
// }
//
// state.enableFeature = bool(state.enableFeature)

// 3. SAFE ARRAY ACCESS
// Check array exists and has length before iteration:
//
// if (myArray && myArray.length > 0) {
//   myArray.forEach(item => {
//     // Process item
//   })
// }

// 4. SAFE OBJECT ACCESS
// Use hasOwnProperty when iterating objects:
//
// for (const key in myObject) {
//   if (myObject.hasOwnProperty(key)) {
//     // Process key/value
//   }
// }

// 5. DEFENSIVE FUNCTION CALLS
// Check function exists before calling:
//
// if (typeof myFunction !== 'undefined' && myFunction !== null) {
//   myFunction()
// }

// ============================================================================
// Don't modify this part - executes the modifier function
// ============================================================================
modifier(text)
